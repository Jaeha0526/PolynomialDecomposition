(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



Clear[a]
JF$Tokenize[line_String]:=StringSplit[StringReplace[line,{"P ":>"P~","N ":>"N~",RegularExpression["(?<=\\d)\\s+(?=\\d)"]->"~"}]," "]/.{
a_String/;StringMatchQ[a,NumberString]:>ToExpression[a],
str_String/;StringMatchQ[str,"a"~~(DigitCharacter...)]:>symbol[str],
str_String/;StringMatchQ[str,"b"~~(DigitCharacter...)]:>symbol[str]
};
JF$ParseSymbol$a[symbol[sym_]]:=symbol[sym]/.symbol[str_String]/;StringMatchQ[str,"a"~~(DigitCharacter...)]:>a[ToExpression[StringTake[str,2;;-1]]];
JF$ParseSymbol$b[symbol[sym_]]:=symbol[sym]/.symbol[str_String]/;StringMatchQ[str,"b"~~(DigitCharacter...)]:>b[ToExpression[StringTake[str,2;;-1]]];


JF$Parser[line_String]:=Module[{result,tail,error},
error=Catch[
{result,tail}=JFP$Read[JF$Tokenize[line]]
];
If[MatchQ[error,Error[__]],Return[False]];
If[Length@tail!=0,Print["JaehaFormat$Parser failure : tail=!={}"];Return[False]];
result/.{
head["+"]:>Plus,head["*"]:>Times,head["^"]:>Power,s_symbol:>JF$ParseSymbol$a[s]}/.{s_symbol:>JF$ParseSymbol$b[s]}
];


Clear[JFP$Read,JFP$ReadN,head];
JFP$ReadN[n_/;n>0,list_List]:=Module[{term1,tail,termrest},
If[list==={},Print["JFP$ReadN wrong : can't read term from {}"];Throw[Error["NoTerm"]];];
{term1,tail}=JFP$Read[list];
{termrest,tail}=JFP$ReadN[n-1,tail];
{Prepend[termrest,term1],tail}];
JFP$ReadN[0,list_List]:={{},list};

JFP$ReadNum[str_String]:=Module[
{list,sign},
list=StringSplit[str,"~"];
sign=list[[1]]/.{"P"->1,"N"->-1};
list=list[[2;;-1]]/.d_String:>ToExpression[d];
sign FromDigits[list,10]
];

JFP$NumQ[str_String]:=StringMatchQ[str,("P"|"N")~~("~"~~(DigitCharacter..))..];

JFP$Read[{numstr_String/;JFP$NumQ[numstr],rest___}]:={JFP$ReadNum[numstr],{rest}};
JFP$Read[{symbol[sym_],rest___}]:={symbol[sym],{rest}};
JFP$Read[{op:("+"|"*"|"^"),rest___}]:=Module[{t1,t2,tail},
{{t1,t2},tail}=JFP$ReadN[2,{rest}];
{head[op][t1,t2],tail}
];

JFP$Read[errterm_]:=(Print["JFP$Read wrong : can't read term from {}"];Throw[Error["JFP$Read failure : ",errterm]];)


MMAExprToJFString$NumberFormat[num_Integer]:={If[num>0,"P","N"]}~Join~IntegerDigits[num,10];


MMAExprToJFString[expr_]:=Module[{},
ToPrefixNotation[expr]/.{
{a,i_}:>{"a"<>ToString[i]}
}/.{
{b,i_}:>{"b"<>ToString[i]}
}/.{Plus->"+",Power->"^",Times->"*"}/.{a_Integer:>MMAExprToJFString$NumberFormat[a]}//Flatten//StringRiffle
];

MMAExprToJFStringNonExpand[expr_]:=Module[{},
ToPrefixNotationNonExpand[expr]/.{
{a,i_}:>{"a"<>ToString[i]}
}/.{
{b,i_}:>{"b"<>ToString[i]}
}/.{Plus->"+",Power->"^",Times->"*"}/.{a_Integer:>MMAExprToJFString$NumberFormat[a]}//Flatten//StringRiffle
]



