(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



Clear[RandomPolynomial];
RandomPolynomial[coeffMin_Integer:0,coeffMax_Integer,degree_Integer,vars_List]:=
Module[{numVars,coeffs,terms,exponents},
numVars=Length[vars];
exponents=Tuples[Range[0,degree],numVars];
coeffs=Table[RandomChoice[{-1,1}]*RandomInteger[{coeffMin,coeffMax}],Length[exponents]-1]
~Join~ {RandomChoice[{-1,1}]*RandomInteger[{Max[1,coeffMin],coeffMax}]};
(* make sure the max degree term doesn't vanish *)
terms=coeffs*(Times@@(vars^#)&/@exponents);
Total[terms]
];


RandomPolynomial$WithHighestCoeff1[intMin_Integer:0,intMax_,degree_,vars_List]:=
Module[{numVars,coeffs,terms,exponents},
numVars=Length[vars];
exponents=Tuples[Range[0,degree],numVars];
coeffs=Table[RandomChoice[{-1,1}]*RandomInteger[{intMin,intMax}],Length[exponents]-1]~Join~{1};

terms=coeffs*(Times@@(vars^#)&/@exponents);
Total[terms]
];


RandomPolynomial$NoConst[intMin_Integer:0,intMax_,degree_,vars_List]:=
Module[{numVars,coeffs,terms,exponents},
numVars=Length[vars];
exponents=Tuples[Range[0,degree],numVars];
coeffs={0}~Join~Table[RandomChoice[{-1,1}]*RandomInteger[{intMin,intMax}],Length[exponents]-2]
~Join~ {RandomChoice[{-1,1}]*RandomInteger[{Max[1,intMin],intMax}]};
(* make sure that the highest degree does not vanish *)
terms=coeffs*(Times@@(vars^#)&/@exponents);
Total[terms]
];


Clear[RandomPolynomial$maxlength];
RandomPolynomial$maxlength[coeffmin_Integer:0,coeffMax_Integer,degree_Integer,vars_List,numterms_Integer]:=
Module[{numVars,coeffs,terms,exponents},
numVars=Length[vars];
exponents=Select[Tuples[Range[0,degree],numVars],0<Total[#]<=degree&];
exponents=RandomSample[exponents,numterms];
coeffs=Table[RandomChoice[{-1,1}]*RandomInteger[{coeffmin,coeffMax}],Length[exponents]];

terms=coeffs*(Times@@(vars^#)&/@exponents);
Total[terms]
];


Clear[RandomPolynomial$maxlength$fix];
RandomPolynomial$maxlength$fix[coeffMax_Integer,degree_Integer,vars_List,numterms_Integer]:=
Module[{numVars,coeffs,terms,exponents},
numVars=Length[vars];
exponents=Select[Tuples[Range[0,degree],numVars],Total[#]==degree&];
exponents=RandomSample[exponents,numterms];
coeffs=RandomInteger[{-coeffMax,coeffMax},Length[exponents]];

terms=coeffs*(Times@@(vars^#)&/@exponents);
If[Total[terms]==0,Return[RandomPolynomial$maxlength$fix[coeffMax,degree,vars,numterms]]];
Total[terms]
];


RandomPolynomial$ON$LSS$VecList[Ngroup_,nvec_]:=Table[a[i],{i,1,Ngroup nvec}]//Partition[#,Ngroup]&;

Clear[RandomPolynomial$ON$LSS];
RandomPolynomial$ON$LSS[intMax_,degMax_,Ngroup_,Nvec_,selectionrule_:None]:=Module[
{short,substitute,long$expand,long},
short=RandomPolynomial[intMax,RandomInteger[{0,degMax}],{s}];
substitute=RandomChoice[RandomPolynomial$ON$LSS$VecList[Ngroup,Nvec]] . RandomChoice[RandomPolynomial$ON$LSS$VecList[Ngroup,Nvec]];
If[Exponent[short,s]<=0,Return[RandomPolynomial$ON$LSS[intMax,degMax,Ngroup,Nvec,selectionrule]]];
{long$expand,long}={short/.s->substitute//Expand,short/.s->substitute};
If[long$expand===0,Print["Warning : ",short, " s=",substitute]];
If[selectionrule=!=None,If[Not@selectionrule[{long$expand,short,substitute}],Return[RandomPolynomial$ON$LSS[intMax,degMax,Ngroup,Nvec,selectionrule]]]];

{long$expand,short,substitute}
];


Clear[RandomPolynomial$ON$LSS2];
RandomPolynomial$ON$LSS2[intMax_,degMax_,Ngroup_,Nvec_,selectionrule_:None]:=Module[
{short,substitute,substitute1,substitute2,substitute3,long$expand,long},
short=RandomPolynomial[intMax,RandomInteger[{1,degMax}],{s}];
substitute1=RandomChoice[RandomPolynomial$ON$LSS$VecList[Ngroup,Nvec]] . RandomChoice[RandomPolynomial$ON$LSS$VecList[Ngroup,Nvec]];
substitute2=RandomChoice[RandomPolynomial$ON$LSS$VecList[Ngroup,Nvec]] . RandomChoice[RandomPolynomial$ON$LSS$VecList[Ngroup,Nvec]];
substitute3=RandomChoice[RandomPolynomial$ON$LSS$VecList[Ngroup,Nvec]] . RandomChoice[RandomPolynomial$ON$LSS$VecList[Ngroup,Nvec]];
substitute=(RandomInteger[{-5,5}]*substitute1+RandomInteger[{-5,5}]*substitute2+RandomInteger[{-5,5}]*substitute3);
If[Exponent[short,s]<=0,Return[RandomPolynomial$ON$LSS2[intMax,degMax,Ngroup,Nvec,selectionrule]]];
{long$expand,long}={short/.s->substitute//Expand,short/.s->substitute};
(*If[long$expand===0,Print["Warning : ",short, " s=",substitute]];*)
If[long$expand===0,Return[RandomPolynomial$ON$LSS2[intMax,degMax,Ngroup,Nvec,selectionrule]]];
If[selectionrule=!=None,If[Not@selectionrule[{long$expand,short,substitute}],Return[RandomPolynomial$ON$LSS2[intMax,degMax,Ngroup,Nvec,selectionrule]]]];
{long$expand,short,substitute}
];


Clear[RandomPolynomial$PolyInPoly$LSS$Special];
RandomPolynomial$PolyInPoly$LSS$Special[intMax_,degMax_,subintMax_,subdegMax_]:=Module[
{short,sub,long$expand,long},
short=RandomPolynomial$NoConst[intMax,degMax,{s}];
sub=RandomPolynomial$WithHighestCoeff1[subintMax,RandomInteger[{1,subdegMax}],{a[1]}];
If[Exponent[short,s]<=0,Return[RandomPolynomial$PolyInPoly$LSS$Special[intMax,degMax,subintMax,subdegMax]]];
If[Exponent[sub,a[1]]<=0,Return[RandomPolynomial$PolyInPoly$LSS$Special[intMax,degMax,subintMax,subdegMax]]];

{long$expand,long}={short/.s->sub//Expand,short/.s->sub};

If[long$expand===0,Print["Warning : ",short, " s=",sub]];
{long$expand,short,sub}
];


Clear[RandomPolynomial$PolyNInPoly1$LSS];
RandomPolynomial$PolyNInPoly1$LSS[intMin_Integer:0,intMax_Integer,degMax_Integer,subintMin_Integer:0,subintMax_Integer,subdegMax_Integer,vars_List,selectionrule_:None,threshold_:0]:=Module[
{short,sub,long$expand,long,retrial},
retrial[]:=RandomPolynomial$PolyNInPoly1$LSS[intMin,intMax,degMax,subintMin,subintMax,subdegMax,vars,selectionrule];

short=RandomPolynomial[intMin,intMax,degMax,{s}];
sub=RandomPolynomial[subintMin,subintMax,RandomInteger[{2,subdegMax}],vars];

If[FreeQ[short,s],Return[retrial[]]];
If[FreeQ[sub,Alternatives@@vars]<=0,Return[retrial[]]];
{long$expand,long}={short/.s->sub//Expand,short/.s->sub};

If[selectionrule=!=None,If[Not@selectionrule[{long$expand,short,sub},threshold],Return[retrial[]]]];

If[long$expand===0,Print["Warning : ",short, " s=",sub]];
{long$expand,short,sub}
];


Clear[RandomPolynomial$PolyNInPoly2$LSS];
RandomPolynomial$PolyNInPoly2$LSS[intMin_Integer:0,intMax_Integer,degMax_Integer,subintMin_Integer:0,subintMax_Integer,subdegMax_Integer,vars_List,selectionrule_:None,threshold_:0]:=Module[
{short,sub,long$expand,long,retrial},
retrial[]:=RandomPolynomial$PolyNInPoly2$LSS[intMin,intMax,degMax,subintMax,subdegMax,vars,selectionrule];

short=RandomPolynomial[intMin,intMax,degMax,{s}];
sub=RandomPolynomial$WithHighestCoeff1[subintMin,subintMax,RandomInteger[{2,subdegMax}],vars];
(* at least have degree 2 substructure *)
If[FreeQ[short,s],Return[retrial[]]];
If[FreeQ[sub,Alternatives@@vars]<=0,Return[retrial[]]];
{long$expand,long}={short/.s->sub//Expand,short/.s->sub};

If[selectionrule=!=None,If[Not@selectionrule[{long$expand,short,sub},threshold],Return[retrial[]]]];

If[long$expand===0,Print["Warning : ",short, " s=",sub]];
{long$expand,short,sub}
];


RandomPolynomial$gen7[subint_List,vars_List]:=
Module[{numVars,coeffs,terms,exponents,degree},
numVars=Length[vars];
degree = (Length[subint]+1)^(1/numVars)-1;
exponents=Tuples[Range[0,degree],numVars];
coeffs=Table[RandomInteger[{subint[[i,1]],subint[[i,2]]}],{i,Length[exponents]-1}]~Join~{1};

terms=coeffs*(Times@@(vars^#)&/@exponents);
Total[terms]
];


Clear[RandomPolynomial$gen7$LSS];
RandomPolynomial$gen7$LSS[intMax_Integer,degMax_Integer,subint_List,vars_List,selectionrule_:None,threshold_:0]:=Module[
{short,sub,long$expand,long,retrial},
retrial[]:=RandomPolynomial$PolyNInPoly2$LSS[intMax,degMax,subint,vars,selectionrule];

short=RandomPolynomial[intMax,degMax,{s}];
sub=RandomPolynomial$gen7[subint,vars];
(* at least have degree 2 substructure *)
If[FreeQ[short,s],Return[retrial[]]];
If[FreeQ[sub,Alternatives@@vars]<=0,Return[retrial[]]];
{long$expand,long}={short/.s->sub//Expand,short/.s->sub};

If[selectionrule=!=None,If[Not@selectionrule[{long$expand,short,sub},threshold],Return[retrial[]]]];

If[long$expand===0,Print["Warning : ",short, " s=",sub]];
{long$expand,short,sub}
];


Clear[RandomPolynomial$PolyNInPoly3$LSS];
RandomPolynomial$PolyNInPoly3$LSS[intMax_Integer,degMax_Integer,subintMax_Integer,subdegMax_Integer,vars_List,
maxlength_Integer,selectionrule_:None,threshold_:0]:=Module[
{short,sub,long$expand,long,retrial},
retrial[]:=RandomPolynomial$PolyNInPoly3$LSS[intMax,degMax,subintMax,subdegMax,vars,maxlength,selectionrule,threshold];

short=RandomPolynomial$WithHighestCoeff1[intMax,degMax,{s}];
sub=RandomPolynomial$maxlength[subintMax,subdegMax,vars,RandomInteger[{1,maxlength}]];

If[FreeQ[short,s],Return[retrial[]]];
If[FreeQ[sub,Alternatives@@vars]<=0,Return[retrial[]]];
{long$expand,long}={short/.s->sub//Expand,short/.s->sub};

If[selectionrule=!=None,If[Not@selectionrule[{long$expand,short,sub},threshold],Return[retrial[]]]];

If[long$expand===0,Print["Warning : ",short, " s=",sub]];
{long$expand,short,sub}
];


Clear[RandomPolynomial$PolyNInPoly4$LSS];
RandomPolynomial$PolyNInPoly4$LSS[intMin_Integer:0,intMax_Integer,degMax_Integer,subintMin_Integer:0,subintMax_Integer,subdegMax_Integer,subvars_List
,maxlength_Integer,subminlength_Integer:1,submaxlength_Integer]:=Module[
{short,sub1,sub2,long$expand,long,retrial},
retrial[]:=RandomPolynomial$PolyNInPoly4$LSS[intMax,degMax,subintMax,subdegMax,subvars,maxlength,submaxlength];

short=RandomPolynomial$maxlength[intMin,intMax,degMax,{b[0],b[1]},maxlength];
sub1=RandomPolynomial$maxlength[subintMin,subintMax,subdegMax,subvars,RandomInteger[{subminlength,submaxlength}]];
sub2=RandomPolynomial$maxlength[subintMin,subintMax,subdegMax,subvars,RandomInteger[{subminlength,submaxlength}]];

long$expand=short/.{b[0]->sub1,b[1]->sub2}//Expand;

If[long$expand===0,retrial[]];
{long$expand,short,sub1,sub2}
];

(*data augmentation with simplification of subset of polynomial*)
Clear[RandomPolynomialWithSplit$PolyNInPoly4$LSS];
RandomPolynomialWithSplit$PolyNInPoly4$LSS[
  intMax_Integer, 
  degMax_Integer, 
  subintMax_Integer, 
  subdegMax_Integer, 
  subvars_List, 
  maxlength_Integer, 
  submaxlength_Integer
] := Module[
  {short, sub1, sub2, long$expand, long$split, terms, half1, half2, retrial},
  
  retrial[] := RandomPolynomialWithSplit$PolyNInPoly4$LSS[
    intMax, degMax, subintMax, subdegMax, subvars, maxlength, submaxlength
  ];

  short = RandomPolynomial$maxlength[intMax, degMax, {b[0], b[1]}, maxlength];
  sub1 = RandomPolynomial$maxlength[subintMax, subdegMax, subvars, RandomInteger[{1, submaxlength}]];
  sub2 = RandomPolynomial$maxlength[subintMax, subdegMax, subvars, RandomInteger[{1, submaxlength}]];

  long$expand = short /. {b[0] -> sub1, b[1] -> sub2} // Expand;
  
   If[Head[long$expand] === Plus,
   terms = List @@ long$expand;
   ,
   terms = {long$expand};
  ];
  
  n = Floor[Length[terms]/2];

  If[n > 1,
   subset1 = Take[terms, n];
   subset2 = Drop[terms, n];
   poly1 = Total[subset1];
   poly2 = Total[subset2] // Simplify;
   long$split = poly1 + poly2,
   long$split = long$expand;
   ];
  {long$expand, long$split, short, sub1, sub2}
];


(*data augmentation with random split of coefficient*)
Clear[extractTerms];
extractTerms[expr_]:= Module[{terms},
If[AtomQ[expr],
terms=If[FreeQ[expr,_Symbol],{},{expr}],
terms=List@@expr;
terms=Select[terms,!FreeQ[#,_Symbol]&];];
terms]

Clear[splitCoefficient];
splitCoefficient[term_]:=Module[{coeff,vars,randSplit},

If[Length[term]-Length[Variables[term]] <= 0,
coeff = 1;
vars = term,
If[Length[Variables[term]]==0,
coeff=term;
vars=1;
,
coeff=Coefficient[term, term/term[[1]]];
vars=term/term[[1]]
];
];

If[coeff==0||coeff==1 || Length[term]-Length[Variables[term]] == 0,
Return[{term, 0}];
,
randSplit=RandomInteger[{1,Abs[coeff]-1}];
Return[{randSplit*vars*Sign[coeff],(Abs[coeff]-randSplit)*vars*Sign[coeff]}];
]
]

Clear[RandomPolynomialWithSplit2$PolyNInPoly4$LSS];
RandomPolynomialWithSplit2$PolyNInPoly4$LSS[
  intMax_Integer, 
  degMax_Integer, 
  subintMax_Integer, 
  subdegMax_Integer, 
  subvars_List, 
  maxlength_Integer, 
  submaxlength_Integer
] := Module[
  {
    short, sub1, sub2, long$expand, splitTerms
  },
  
  short = RandomPolynomial$maxlength[intMax, degMax, {b[0], b[1]}, maxlength];
  sub1 = RandomPolynomial$maxlength[subintMax, subdegMax, subvars, RandomInteger[{1, submaxlength}]];
  sub2 = RandomPolynomial$maxlength[subintMax, subdegMax, subvars, RandomInteger[{1, submaxlength}]];
  
  long$expand = short /. {b[0] -> sub1, b[1] -> sub2} // Expand;
  
  If[Length[long$expand]>1 && Head[long$expand] === Plus,
    splitTerms=Flatten[Flatten[splitCoefficient/@(List@@long$expand), 1]];
  ,
    If[long$expand === 0,
      splitTerms = 0;,
      splitTerms=Inactive[Plus]@@splitCoefficient[long$expand];
    ];
  ];
  {long$expand, Inactive[Plus]@@splitTerms, short, sub1, sub2}
];


(*data augmentation with random split of coefficient*)
Clear[extractTerms];
extractTerms[expr_]:= Module[{terms},
If[AtomQ[expr],
terms=If[FreeQ[expr,_Symbol],{},{expr}],
terms=List@@expr;
terms=Select[terms,!FreeQ[#,_Symbol]&];];
terms]

Clear[splitCoefficient2];
splitCoefficient2[term_]:=Module[{coeff,vars,randSplit,choice,randterm},

If[Length[Variables[term]]==0,
randterm=RandomInteger[{0,term}];
Return[RandomChoice[{{randterm,term-randterm},{term}}]];,
term 
];
If[Length[term]-Length[Variables[term]] <= 0,
coeff = 1;
vars = term;
Return[term],
coeff=Coefficient[term, term/term[[1]]];
vars=term/term[[1]]
];
If[coeff==0||coeff==1||Length[term]-Length[Variables[term]] == 0,
Return[{term}];
,
randSplit=RandomInteger[{1,Abs[coeff]-1}];
choice=RandomChoice[{0,1}];
If[choice==0,
Return[{randSplit*vars*Sign[coeff],(Abs[coeff]-randSplit)*vars*Sign[coeff]}],
Return[{Abs[coeff]*vars*Sign[coeff]}]
];
];
]

Clear[RandomPolynomialWithSplit2$PolyNInPoly2$LSS];
RandomPolynomialWithSplit2$PolyNInPoly2$LSS[
  intMax_Integer, 
  degMax_Integer, 
  subintMax_Integer, 
  subdegMax_Integer, 
  vars_List
] := Module[
  {
    short, sub, long$expand, retrial, splitTerms
  },
  
retrial[]:=RandomPolynomialWithSplit2$PolyNInPoly2$LSS[intMax,degMax,subintMax,subdegMax,vars];

short=RandomPolynomial[intMax,degMax,{s}];
sub=RandomPolynomial$WithHighestCoeff1[subintMax,RandomInteger[{2,subdegMax}],vars];

If[FreeQ[short,s],Return[retrial[]]];
If[FreeQ[sub,Alternatives@@vars]<=0,Return[retrial[]]];
{long$expand,long}={short/.s->sub//Expand,short/.s->sub};
If[long$expand===0,Print["Warning : ",short, " s=",sub]];

 
  If[Length[long$expand]>1 && Head[long$expand] === Plus,
    splitTerms=Flatten[Flatten[splitCoefficient2/@(List@@long$expand), 1]];
  ,
    If[long$expand === 0,
      splitTerms = 0;,
      splitTerms=Inactive[Plus]@@splitCoefficient2[long$expand];
    ];
  ];
  {long$expand,Inactive[Plus]@@splitTerms,short,sub}
];

(* Multivariable Experiment w/ Distribute *)
CombineMyPlus[expr_] := Module[{result},
  result = expr /. {
    (* Case 1: List of myplus expressions *)
    List[a___, myplus[b___], c___, myplus[d___], e___] :> 
      List[a, myplus[b, d], c, e],
    
    (* Case 2: Single element in myplus *)
    List[a___, elem_, b___] /; FreeQ[elem, myplus] :> 
      List[a, myplus[elem], b]
  };
  
  (* If the result still contains multiple myplus expressions, keep combining *)
  If[Count[result, _myplus, Infinity] > 1,
    result = CombineMyPlus[result]
  ];
  
  (* Finally, combine all remaining elements into single myplus *)
  myplus @@ Flatten[result /. myplus -> List]
]

DistributeExpression[expr_] := Module[{result},
  ClearAttributes[mytimes, {Flat, OneIdentity}];
  ClearAttributes[myplus, {Flat, OneIdentity}];
  
  SetAttributes[mytimes, {Flat, OneIdentity}];
  SetAttributes[myplus, {Flat, OneIdentity}];
  
  result = expr /. Inactive -> Identity /. Times -> mytimes /. Power -> mypow;
  result = result /. mypow[exp_, n_] :> mytimes @@ Table[exp, n];
  result = result /. Plus -> myplus;
  result = Distribute[result, myplus, mytimes];
  result = result /. mytimes -> Times;
  result = result /. mypow -> Power;
  (*result = result /. myplus -> Inactive[Plus];*)
  
  ClearAttributes[mytimes, {Flat, OneIdentity}];
  ClearAttributes[myplus, {Flat, OneIdentity}];
  
  result
]

Clear[RandomPolynomialWithDistribute$PolyNInPoly4$LSS];
RandomPolynomialWithDistribute$PolyNInPoly4$LSS[
  intMax_Integer, 
  degMax_Integer, 
  subintMax_Integer, 
  subdegMax_Integer, 
  subvars_List, 
  maxlength_Integer, 
  submaxlength_Integer
] := Block[
  {short, sub1, sub2, expandedForm, nonExpandedForm, distributedForm},  (* Renamed variables *)
  short = RandomPolynomial$maxlength[intMax, degMax, {b[0], b[1]}, maxlength];
  sub1 = RandomPolynomial$maxlength[subintMax, subdegMax, subvars, RandomInteger[{1, submaxlength}]];
  sub2 = RandomPolynomial$maxlength[subintMax, subdegMax, subvars, RandomInteger[{1, submaxlength}]];
  
  SetAttributes[mytimes, {Flat, OneIdentity}];
  SetAttributes[myplus, {Flat, OneIdentity}];
  
(*  Print["Original Expression:"];
  Print[short /. {b[0] -> sub1, b[1] -> sub2}];*)
  
  expandedForm = Expand[short /. {b[0] -> sub1, b[1] -> sub2}];
  nonExpandedForm = short /. {b[0] -> sub1, b[1] -> sub2};
  
  If[Length[nonExpandedForm]>1 && Head[nonExpandedForm] === Plus,
(*    Print["Non Expanded Form List:"];
    Print[List @@ nonExpandedForm];*)
    distributedForm = CombineMyPlus[DistributeExpression/@(List @@ nonExpandedForm)] /. myplus -> Inactive[Plus]
  ,
    distributedForm = expandedForm;
  ];
  
(*  Print["Distributed Form:"];
  Print[distributedForm];*)
  
  {expandedForm, distributedForm, short, sub1, sub2}
]


(* Variable (Original / Substituion): 3, 3 *)
(* Degree (Original / Substituion): 3, 3 *)
Clear[RandomPolynomialWithDistributeVar3$PolyNInPoly4$LSS];
RandomPolynomialWithDistributeVar3$PolyNInPoly4$LSS[
  intMax_Integer, 
  degMax_Integer, 
  subintMax_Integer, 
  subdegMax_Integer, 
  subvars_List, 
  maxlength_Integer, 
  submaxlength_Integer
] := Block[
  {short, sub1, sub2, sub3, expandedForm, nonExpandedForm, distributedForm},  (* Added sub3 *)
  short = RandomPolynomial$maxlength[intMax, degMax, {b[0], b[1], b[2]}, maxlength];
  sub1 = RandomPolynomial$maxlength[subintMax, subdegMax, subvars, RandomInteger[{1, submaxlength}]];
  sub2 = RandomPolynomial$maxlength[subintMax, subdegMax, subvars, RandomInteger[{1, submaxlength}]];
  sub3 = RandomPolynomial$maxlength[subintMax, subdegMax, subvars, RandomInteger[{1, submaxlength}]];
  
  SetAttributes[mytimes, {Flat, OneIdentity}];
  SetAttributes[myplus, {Flat, OneIdentity}];
  
  expandedForm = Expand[short /. {b[0] -> sub1, b[1] -> sub2, b[2] -> sub3}];
  nonExpandedForm = short /. {b[0] -> sub1, b[1] -> sub2, b[2] -> sub3};
  
  If[Length[nonExpandedForm]>1 && Head[nonExpandedForm] === Plus,
    distributedForm = CombineMyPlus[DistributeExpression/@(List @@ nonExpandedForm)] /. myplus -> Inactive[Plus]
  ,
    distributedForm = expandedForm;
  ];
  
  {expandedForm, distributedForm, short, sub1, sub2, sub3}
]


Clear[RandomPolynomial$PolyNInPoly5$LSS];
RandomPolynomial$PolyNInPoly5$LSS[intMax_Integer,degMax_Integer,subintMax_Integer,subdegMax_Integer,subvars_List,subvars2_List,
maxlength_Integer,submaxlength_Integer]:=Module[
{short,sub1,sub2,long$expand,long,retrial},
retrial[]:=RandomPolynomial$PolyNInPoly5$LSS[intMax,degMax,subintMax,subdegMax,subvars,maxlength,submaxlength];

short=RandomPolynomial$maxlength$fix[intMax,degMax,{b[0],b[1]},maxlength];
sub1=RandomPolynomial$maxlength$fix[subintMax,subdegMax,subvars,RandomInteger[{1,submaxlength}]];
sub2=RandomPolynomial$maxlength$fix[subintMax,subdegMax,subvars2,RandomInteger[{1,submaxlength}]];

long$expand=short/.{b[0]->sub1,b[1]->sub2}//Expand;

If[long$expand===0,retrial[]];
{long$expand,short,sub1,sub2}
];


Clear[RandomPolynomial$PolyNInPoly6$LSS];
(*
intMax : max coefficient of original expression
degMax : degree of terms in original expression ( all has same degree )
subintMax : max coefficient of substitution
subdegMax : degree of terms in substitutions ( all has same degree )
originvars : set of variables in original expression
subvars : set of variables in substitutions
maxlength : max number of terms of original expression - fixed
submaxlength : max number of terms of substitutions - not fixed
*)
RandomPolynomial$PolyNInPoly6$LSS[intMax_Integer,degMax_Integer,subintMax_Integer,subdegMax_Integer,originvars_List,subvars_List,
maxlength_Integer,submaxlength_Integer]:=Module[
{short,sub,long$expand,long,retrial,originvarslen},
retrial[]:=RandomPolynomial$PolyNInPoly6$LSS[intMax,degMax,subintMax,subdegMax,originvars,subvars,maxlength,submaxlength];

originvarslen = Length[originvars];
short=RandomPolynomial$maxlength$fix[intMax,degMax,originvars,maxlength];
sub=Table[RandomPolynomial$maxlength$fix[subintMax,subdegMax,subvars,RandomInteger[{1,submaxlength}]],originvarslen];

long$expand=short/. Thread[originvars -> sub]//Expand;

Table[If[sub[[i]]===0,retrial[]],{i,originvarslen}];
If[long$expand===0,retrial[]];
{long$expand,short} ~Join~ sub
];

(* Multivariable Experiment w/ Distribute *)
CombineMyPlus[expr_] := Module[{result},
  result = expr /. {
    (* Case 1: List of myplus expressions *)
    List[a___, myplus[b___], c___, myplus[d___], e___] :> 
      List[a, myplus[b, d], c, e],
    
    (* Case 2: Single element in myplus *)
    List[a___, elem_, b___] /; FreeQ[elem, myplus] :> 
      List[a, myplus[elem], b]
  };
  
  (* If the result still contains multiple myplus expressions, keep combining *)
  If[Count[result, _myplus, Infinity] > 1,
    result = CombineMyPlus[result]
  ];
  
  (* Finally, combine all remaining elements into single myplus *)
  myplus @@ Flatten[result /. myplus -> List]
]

DistributeExpression[expr_] := Module[{result},
  ClearAttributes[mytimes, {Flat, OneIdentity}];
  ClearAttributes[myplus, {Flat, OneIdentity}];
  
  SetAttributes[mytimes, {Flat, OneIdentity}];
  SetAttributes[myplus, {Flat, OneIdentity}];
  
  result = expr /. Inactive -> Identity /. Times -> mytimes /. Power -> mypow;
  result = result /. mypow[exp_, n_] :> mytimes @@ Table[exp, n];
  result = result /. Plus -> myplus;
  result = Distribute[result, myplus, mytimes];
  result = result /. mytimes -> Times;
  result = result /. mypow -> Power;
  (*result = result /. myplus -> Inactive[Plus];*)
  
  ClearAttributes[mytimes, {Flat, OneIdentity}];
  ClearAttributes[myplus, {Flat, OneIdentity}];
  
  result
]

Clear[RandomPolynomial$PolyNInPoly6$LSS$Distribute];
(*
intMax : max coefficient of original expression
degMax : degree of terms in original expression ( all has same degree )
subintMax : max coefficient of substitution
subdegMax : degree of terms in substitutions ( all has same degree )
originvars : set of variables in original expression
subvars : set of variables in substitutions
maxlength : max number of terms of original expression - fixed
submaxlength : max number of terms of substitutions - not fixed
*)
RandomPolynomial$PolyNInPoly6$LSS$Distribute[intMax_Integer,degMax_Integer,subintMax_Integer,subdegMax_Integer,originvars_List,subvars_List,
maxlength_Integer,submaxlength_Integer]:=Module[
{short,sub,long$expand,long,retrial,originvarslen},
retrial[]:=RandomPolynomial$PolyNInPoly6$LSS[intMax,degMax,subintMax,subdegMax,originvars,subvars,maxlength,submaxlength];

originvarslen = Length[originvars];
short=RandomPolynomial$maxlength$fix[intMax,degMax,originvars,maxlength];
sub=Table[RandomPolynomial$maxlength$fix[subintMax,subdegMax,subvars,RandomInteger[{1,submaxlength}]],originvarslen];

  SetAttributes[mytimes, {Flat, OneIdentity}];
  SetAttributes[myplus, {Flat, OneIdentity}];

  expandedForm = short/. Thread[originvars -> sub]//Expand;
  nonExpandedForm = short/. Thread[originvars -> sub];

  If[Length[nonExpandedForm]>1 && Head[nonExpandedForm] === Plus,
    distributedForm = CombineMyPlus[DistributeExpression/@(List @@ nonExpandedForm)] /. myplus -> Inactive[Plus]
  ,
    distributedForm = expandedForm;
  ];

Table[If[sub[[i]]===0,retrial[]],{i,originvarslen}];
If[expandedForm===0 Or expandedForm === distributedForm,retrial[]];
{expandedForm, distributedForm, short} ~Join~ sub
];


Clear[RandomPolynomial$PolyNInPoly7$LSS];
(*
intMax : max coefficient of original expression
degMax : degree of terms in original expression ( all has same degree )
subintMax : max coefficient of substitution
subdegMax : degree of terms in substitutions ( all has same degree )
originvars : set of variables in original expression
subvars : set of variables in substitutions
maxlength : max number of terms of original expression - not fixed
submaxlength : max number of terms of substitutions - fixed
*)
RandomPolynomial$PolyNInPoly7$LSS[intMax_Integer,degMax_Integer,subintMax_Integer,subdegMax_Integer,originvars_List,subvars_List,
maxlength_Integer,submaxlength_Integer]:=Module[
{short,sub,long$expand,long,retrial,originvarslen},
retrial[]:=RandomPolynomial$PolyNInPoly7$LSS[intMax,degMax,subintMax,subdegMax,originvars,subvars,maxlength,submaxlength];

originvarslen = Length[originvars];
short=RandomPolynomial$maxlength$fix[intMax,degMax,originvars,RandomInteger[{1,maxlength}]];
sub=Table[RandomPolynomial$maxlength$fix[subintMax,subdegMax,subvars,submaxlength],originvarslen];

long$expand=short/. Thread[originvars -> sub]//Expand;

Table[If[sub[[i]]===0,retrial[]],{i,originvarslen}];
If[long$expand===0,retrial[]];
{long$expand,short} ~Join~ sub
];


Clear[RandomPolynomial$PolyNInPoly8$LSS];
RandomPolynomial$PolyNInPoly8$LSS[intMin_Integer:0,intMax_Integer,degMax_Integer,subintMin_Integer:0,subintMax_Integer,subdegMax_Integer,vars_List,selectionrule_:None,threshold_:0]:=Module[
{short,sub,long$expand,long,retrial},
retrial[]:=RandomPolynomial$PolyNInPoly8$LSS[intMin,intMax,degMax,subintMax,subdegMax,vars,selectionrule];

short=RandomPolynomial[intMin,intMax,RandomInteger[{2,degMax}],{s}];
sub=RandomPolynomial[subintMin,subintMax,RandomInteger[{2,subdegMax}],vars];
(* at least have degree 2 substructure *)
If[FreeQ[short,s],Return[retrial[]]];
If[FreeQ[sub,Alternatives@@vars]<=0,Return[retrial[]]];
{long$expand,long}={short/.s->sub//Expand,short/.s->sub};

If[selectionrule=!=None,If[Not@selectionrule[{long$expand,short,sub},threshold],Return[retrial[]]]];

If[long$expand===0,Print["Warning : ",short, " s=",sub]];
{long$expand,short,sub}
];


(*ToPrefixNotation[expr_]:=Module[{recurse,step1},
If[NumericQ[expr],Return[{expr}]];
step1=expr/.{Inactive[Plus]->plus, Plus\[Rule]plus,Times\[Rule]times}//.{
plus[a_,b_,c__]\[RuleDelayed]plus[a,plus[b,c]],
times[a_,b_,c__]\[RuleDelayed]times[a,times[b,c]]};

recurse[exp_/;AtomQ[exp]]:=exp;
recurse[exp_]:=Prepend[recurse/@List@@exp,Head[exp]];

recurse[step1]/.{plus\[Rule]Plus,times\[Rule]Times}
];*)



ToPrefixNotation[expr_]:=Module[{stack={},output={},temp,step1,currentExpr,head,elems},
(*If expression is numeric,return it as a list*)
If[NumericQ[expr],Return[{expr}]];
(*Helper function to handle Plus and Times transformations*)step1=expr/. {Inactive[Plus]->plus,Plus->plus,Times->times}//.{plus[a_,b_,c__]:>plus[a,plus[b,c]],times[a_,b_,c__]:>times[a,times[b,c]]};
step1=step1/. {a[i_]:>"a"<>ToString[i]}/. {b[i_]:>"b"<>ToString[i]};
(*Initialize the stack with the modified expression*)
stack={step1};
(*Process each element in the stack iteratively*)
While[
Length[stack]>0,
currentExpr=First[stack];
stack=Rest[stack];
If[AtomQ[currentExpr],AppendTo[output,currentExpr],head=Head[currentExpr];
elems=List@@currentExpr;
(*Append the head to the output and push elements onto the stack*)
AppendTo[output,head];
stack=Join[elems,stack];
];
];
(*Return the output with transformations back to Plus and Times*)
output/. {plus->Plus,times->Times}]


(* treat a[n] as 1 count *)
MyLeafCount$CleanSymbol[expr_]:=expr/.a[n_]:>"a"<>ToString[n];
MyLeafCount[expr_]:=LeafCount@MyLeafCount$CleanSymbol[expr];

ComplexityCriteria[{expr$unsimplified_,expr$simplifed_,expr$sub_},reduce$threshold_:0]:=Module[
{count$simplified,count$sub,count$unsimplified},
{count$unsimplified,count$simplified,count$sub}=MyLeafCount/@{expr$unsimplified,expr$simplifed,expr$sub};
If[count$unsimplified>count$simplified+count$sub+reduce$threshold,True,False]
];


Clear[ExprToDAG]
ExprToDAG[{expr_,rule_}]:=Module[
{subexpr$pos,subexprlist,smax,newrule,replacerule},
subexpr$pos=ExprToDAG$FoundIdenticalSubexpr[expr];
subexprlist=Table[expr[[Sequence@@subexpr$pos[[i,1]]]],{i,Length[subexpr$pos]}];

smax=Cases[expr,_s,Infinity]//DeleteDuplicates;
smax=Max[smax[[All,1]]~Join~{0}];

newrule=Table[s[smax+i]->subexprlist[[i]],{i,Length[subexprlist]}];

replacerule=Table[#->s[smax+i]&/@subexpr$pos[[i]],{i,Length[subexprlist]}]//Flatten;

{ReplacePart[expr,replacerule],rule~Join~newrule}
];
ExprToDAG[expr_]:=ExprToDAG[{expr,{}}];

ExprToDAG$FoundIdenticalSubexpr[expr_]:=Module[
{allhash,allhash$gather,subexpr},
allhash=MapIndexed[Module[{content=#1,pos=#2},Sow[pos->Hash[content]];content]&,expr,All]//Reap;
allhash=allhash[[2,1]];
allhash$gather=GatherBy[allhash,Last]//Select[#,Length[#]>1&][[All,All,1]]&;

subexpr=Select[allhash$gather,MyLeafCount[expr[[Sequence@@#[[1]]]]]>1&];
subexpr//ExprToDAG$Maximum
];


(* Alist, Blist are lists of positions. This function check whether all nodes in Alist are subnodes of certain nodes in Blist *)
ExprToDAG$SubnodesQ[Alist_,Blist_]:=And@@Table[
MatchQ[Alist[[i]],Alternatives@@(Append[#,__]&/@Blist)]
,{i,1,Length[Alist]}];

ExprToDAG$Compare[Alist_,Blist_]:=Which[
ExprToDAG$SubnodesQ[Alist,Blist],-1,
ExprToDAG$SubnodesQ[Blist,Alist],1,
True,0
];


ExprToDAG$Maximum[list_]:=Module[
{todelete={}},
Do[If[ExprToDAG$SubnodesQ[list[[i]],list[[j]]],AppendTo[todelete,i ] ],{i,Length[list]},{j,Length[list]}];
todelete=DeleteDuplicates[todelete];
Delete[list,List/@todelete]
];


PolynomialDecomposite[raw_,sub_]:=Module[{coeff,result,reminder},
Clear[s,p];
result=p;
coeff=raw;
While[True,
If[coeff==0,Break[]];
{{coeff},reminder}=PolynomialReduce[coeff,sub];
result=result/.p->p s+reminder;
];
result=result/.p->0;
result
];


Clear[PolySimplifyWithHint$Special]
PolySimplifyWithHint$Special[{expr$unsimplified_,expr$sub_}]:=Module[
{expr$simplifed},
expr$simplifed=PolynomialDecomposite[expr$unsimplified,expr$sub]//Expand;
If[Not@FreeQ[expr$simplifed,_a],False,expr$simplifed]
];
PolySimplifyWithHint$Special[{expr$unsimplified_,False}]:=False;


Clear[PolySimplifyWithHint]
PolySimplifyWithHint[{expr$unsimplified_,expr$sub_},complexityCriteriaQ_:True,eliminateQ_:True]:=Module[
{expr$simplifed},
If[NumericQ[expr$unsimplified],Return[True]];
expr$simplifed=PolynomialDecomposite[expr$unsimplified,expr$sub]//Expand;
If[eliminateQ && Not@FreeQ[expr$simplifed,_a],Return[False]];
If[complexityCriteriaQ && Not@ComplexityCriteria[{expr$unsimplified,expr$simplifed,expr$sub}],Return[False]];
Return[expr$simplifed]
];
PolySimplifyWithHint[{expr$unsimplified_,False},___]:=False;


Clear[PolySimplifyCheckSubShort]
PolySimplifyCheckSubShort[{expr$unsimplified_,expr$sub$short_}]:=Module[
{expr$simplified,expr$sub,expr$short},
expr$sub=expr$sub$short[[1]];
expr$short=expr$sub$short[[2]];
expr$simplified=expr$short/.{b[0]->expr$sub}//Expand;
If[Expand[expr$unsimplified-expr$simplified]==0,Return[True]];
Return[False];
];
PolySimplifyCheckSubShort[{expr$unsimplified_,False}]:=False;


Clear[PolySimplifyCheckSubShort2]
PolySimplifyCheckSubShort2[{expr$unsimplified_,expr$sub$short_}]:=Module[
{expr$simplified,expr$sub1,expr$sub2,expr$short},
If[expr$sub$short==False,Return[False]];
expr$sub1=expr$sub$short[[1,1]];
expr$sub2=expr$sub$short[[1,2]];
expr$short=expr$sub$short[[2]];
expr$simplified=expr$short/.{b[0]->expr$sub1,b[1]->expr$sub2}//Expand;
If[Expand[expr$unsimplified-expr$simplified]==0,Return[True]];
Return[False];
];


ConvertL2toL1[str_String]:=Module[{},
StringReplace[str,{
"A"~~n:DigitCharacter:>"a"<>n,
"B"~~n:DigitCharacter:>"b"<>n,
"S"~~n:DigitCharacter:>n,
"P2":>"P",
"N2":>"N",

"*2":>"*",
"+2":>"+"
}]
];

PredictionData$FromFile[filename_]:=Module[
{data},
data=(DeleteCases[#1,""]&)[StringSplit[ConvertL2toL1@Import[filename],"\n"|"\:2047"]];
data=data[[2;;-1;;2]];
data=StringSplit[data,"$"]//DeleteCases[#,""]&;
data=data/.str_String:>JF$Parser[str];
data
];


LongSubPair$ReadFile[filename_]:=StringSplit[Import[filename],"\n"];

LongSubPair$FromString[txt_String]:=Module[
{data},
data=StringSplit[txt," ? "];
If[Dimensions[data]=!={2},Print["readDataSet failed. Wrong format."]];
data=data/.str_String:>JF$Parser[str];
data
];
LongSubPair$FromFile[filename_]:=StringSplit[ConvertL2toL1@Import[filename],"\n"]/. str_String:>LongSubPair$FromString[str];
TestData$FromFile=LongSubPair$FromFile;


TestData$FromFile2[filename_]:=Module[
{data},
data=StringSplit[Import[filename],"\n"|"?"]//DeleteCases[#,""]&;
data=data[[1;;-2;;2]];
data=data/.str_String:>JF$Parser[str];
data
];


TestData$FromFile2$both[filename_]:=Module[
{data,dataq,dataa},
data=StringSplit[Import[filename],"\n"|"?"]//DeleteCases[#,""]&;
dataq=data[[1;;-2;;2]];
dataa=data[[2;;-1;;2]];
dataa=StringSplit[dataa,"&"]//DeleteCases[#,""]&;
data=Table[{dataq[[i]]/.str_String:>JF$Parser[str]}~Join~dataa[[i]]/.str_String:>JF$Parser[str],{i,Length[dataq]}];
data
];


TestData$FromFile2$answers[filename_]:=Module[
{data},
data=StringSplit[Import[filename],"\n"|"?"]//DeleteCases[#,""]&;
data=data[[2;;-1;;2]];
data=StringSplit[data,"&"]//DeleteCases[#,""]&;
data=Table[If[Length[data[[i]]]==2,{StringSplit[data[[i,1]],"$"]//DeleteCases[#,""]&,data[[i,2]]},False],{i,Length[data]}];
data=data/.str_String:>JF$Parser[str];
data
];


PredictionData$FromFile2[filename_]:=Module[
{data},
data=StringSplit[Import[filename],"\n"|"\:2047"]//DeleteCases[#,""]&;
data=data[[2;;-1;;2]];
data=StringSplit[data,"&"]//DeleteCases[#,""]&;
data=Table[If[Length[data[[i]]]==2,{StringSplit[data[[i,1]],"$"]//DeleteCases[#,""]&,data[[i,2]]},False],{i,Length[data]}];
data=data/.str_String:>JF$Parser[str];
data
];


PredictionData$FromFile3[filename_]:=Module[
{data},
data=StringSplit[Import[filename],"\n"|"\:2047"]//DeleteCases[#,""]&;
data=data[[2;;-1;;2]];
data=StringSplit[data,"&"]//DeleteCases[#,""]&;
data=data/.str_String:>JF$Parser[str];
data
];


EvaluateSimplificationResult[testfile_,predictionfile_,complexityCriteriaQ_:True,eliminateQ_:True]:=Module[
{testdata,predictiondata,simplification$result,pctg$grammaticerr,pctg$wrong,pctg$correct},
testdata=TestData$FromFile[testfile];
predictiondata=PredictionData$FromFile[predictionfile];
simplification$result=Table[PolySimplifyWithHint[{testdata[[i,1]],predictiondata[[i,1]]},complexityCriteriaQ,eliminateQ],{i,1,Length@predictiondata}];

pctg$grammaticerr=Count[predictiondata,False]/Length[predictiondata]//N;
pctg$wrong=Count[simplification$result,False]/Length[simplification$result]-pctg$grammaticerr//N;
pctg$correct=1-Count[simplification$result,False]/Length[simplification$result]//N;

{pctg$grammaticerr,pctg$wrong,pctg$correct}
];


EvaluateSimplificationResult2[testfile_,predictionfile_]:=Module[
{testdata,predictiondata,simplification$result,pctg$grammaticerr,pctg$wrong,pctg$correct},
testdata=TestData$FromFile2[testfile];
predictiondata=PredictionData$FromFile[predictionfile];
predictiondata=Table[If[Length[predictiondata[[i]]]==2, predictiondata[[i]], False],{i,Length[predictiondata]}];
simplification$result=Table[PolySimplifyCheckSubShort[{testdata[[i]],predictiondata[[i]]}],{i,1,Length@predictiondata}];

pctg$grammaticerr=Count[predictiondata,False]/Length[predictiondata]//N;
pctg$wrong=Count[simplification$result,False]/Length[simplification$result]-pctg$grammaticerr//N;
pctg$correct=1-Count[simplification$result,False]/Length[simplification$result]//N;

{pctg$grammaticerr,pctg$wrong,pctg$correct}
];


EvaluateSimplificationResult3[testfile_,predictionfile_]:=Module[
{testdata,predictiondata,simplification$result,pctg$grammaticerr,pctg$wrong,pctg$correct,test$grammaticerr},
testdata=TestData$FromFile2[testfile];
predictiondata=PredictionData$FromFile2[predictionfile];
predictiondata=Table[If[Length[predictiondata[[i]]]==2 && Length[predictiondata[[i,1]]]==2,predictiondata[[i]],False],{i,Length[predictiondata]}];
simplification$result=Table[PolySimplifyCheckSubShort2[{testdata[[i]],predictiondata[[i]]}],{i,1,Length@predictiondata}];

test$grammaticerr=Count[testdata,False]/Length[testdata]//N;
pctg$grammaticerr=Count[predictiondata,False]/Length[predictiondata]//N;
pctg$wrong=Count[simplification$result,False]/Length[simplification$result]-pctg$grammaticerr//N;
pctg$correct=1-Count[simplification$result,False]/Length[simplification$result]//N;

{test$grammaticerr,pctg$grammaticerr,pctg$wrong,pctg$correct,simplification$result}
];



